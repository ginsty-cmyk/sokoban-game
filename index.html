<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sokoban Speedrun: HYPER-SPEED</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root { 
            --bg: #050505; --panel: rgba(30, 30, 30, 0.85); --accent: #00d2ff; 
            --danger: #ff0040; --success: #00ff88; --text: #ffffff; 
        }
        * { 
            user-select: none; 
            -webkit-tap-highlight-color: transparent; 
            box-sizing: border-box; 
            /* 允许手势用于 JS 监听 */
            touch-action: none; 
        }
        body { 
            background: var(--bg); display: flex; flex-direction: column; align-items: center; 
            font-family: 'Orbitron', sans-serif; color: var(--text); 
            margin: 0; overflow: hidden; height: 100vh; position: fixed; width: 100%;
        } 
        
        #bg-canvas { position: absolute; top: 0; left: 0; z-index: -1; width: 100%; height: 100%; }

        #timer-box {
            margin-top: 25px; text-align: center; background: var(--panel);
            padding: 15px 40px; border-radius: 4px; border-right: 4px solid var(--danger);
            box-shadow: 0 0 20px rgba(255, 0, 64, 0.3); z-index: 10;
        }
        #st { 
            font-family: 'Share Tech Mono', monospace; font-size: 3.5rem; 
            font-weight: bold; color: var(--danger); text-shadow: 0 0 10px rgba(255, 0, 64, 0.8);
            line-height: 1; display: inline-block;
        }
        .ms { font-size: 1.5rem; opacity: 0.8; margin-left: 2px; }
        .timer-label { font-size: 0.7rem; text-transform: uppercase; color: #aaa; letter-spacing: 4px; margin-bottom: 5px;}

        .pulse { animation: pulse 0.1s linear; }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        #ui-stats { margin: 15px 0; display: flex; gap: 20px; font-size: 1rem; align-items: center; z-index: 10; }
        .stat-item span { color: var(--accent); font-weight: 900; }

        #reset-btn {
            background: none; color: var(--danger); border: 2px solid var(--danger); padding: 8px 18px;
            font-family: 'Orbitron'; font-weight: 900; cursor: pointer; transition: 0.2s;
            touch-action: manipulation; 
        }
        #reset-btn:hover { background: var(--danger); color: white; }

        #game-container { position: relative; flex-grow: 1; display: flex; justify-content: center; align-items: center; width: 100%; z-index: 5;/* 关键：在手机端通过设置 padding-bottom 或 transform 将内容向上拉 */
    padding-bottom: 15vh; }
        canvas#cvs { background: rgba(10, 10, 10, 0.9); border: 1px solid rgba(0, 210, 255, 0.3); outline: none;}
        canvas {
    outline: none;
    -webkit-touch-callout: none; /* 禁止 iOS 长按弹出菜单 */
}

        .modal { 
            display: none; position: fixed; inset: 0; 
            background: rgba(0,0,0,0.98); backdrop-filter: blur(20px);
            justify-content: center; align-items: center; z-index: 100; 
        }
        .modal-content { 
            background: linear-gradient(145deg, #111, #222); color: #fff; padding: 40px; 
            border: 1px solid var(--accent); width: 90%; max-width: 450px; text-align: center;
        }
        .score-val { font-size: 60px; font-weight: 900; color: var(--danger); font-family: 'Orbitron'; }
        .result-grid { 
            text-align: left; margin: 25px 0; display: grid; grid-template-columns: 1fr 1fr; gap: 15px;
            font-family: 'Share Tech Mono'; border-top: 1px solid #333; padding-top: 20px;
        }
        .result-label { color: #888; font-size: 0.8rem; }
        .result-data { color: #fff; font-size: 1.1rem; display: block; }
        
        #msg { position: fixed; top: 15%; font-size: 40px; color: var(--success); font-weight: 900; opacity: 0; transition: 0.2s; pointer-events: none; z-index: 50; }
    </style>
</head>
<body>
    <canvas id="bg-canvas"></canvas>
    <div id="msg">GOAL!!!</div>
    <div id="timer-box"><div class="timer-label">Mission Elapsed</div><div id="st">00<span class="ms">.000</span></div></div>
    <div id="ui-stats">
        <div class="stat-item">SECTOR: <span id="lv">1</span>/12</div>
        <div class="stat-item">STP: <span id="steps">0</span></div>
        <button id="reset-btn">ABORT (R)</button>
    </div>
    <div id="game-container"><canvas id="cvs"></canvas></div>

    <div id="res" class="modal">
        <div class="modal-content">
            <h2>DEBRIEFING</h2>
            <div id="f-score" class="score-val">0</div>
            <p id="f-rank" style="font-weight:900; font-size:2rem; margin:10px 0;">RANK: S</p>
            <div class="result-grid">
                <div><span class="result-label">TOTAL STEPS</span><span class="result-data" id="f-steps">0</span></div>
                <div><span class="result-label">MIN STEPS REF</span><span class="result-data" id="f-min" style="color:var(--success)">0</span></div>
                <div><span class="result-label">PURE TIME</span><span class="result-data" id="f-pure">0s</span></div>
                <div><span class="result-label">PENALTY</span><span class="result-data" id="f-penalty" style="color:var(--danger)">+0s</span></div>
            </div>
            <button onclick="location.reload()" style="background:var(--accent); color:#000; border:none; padding:15px 40px; font-family:'Orbitron'; font-weight:900; cursor:pointer; width:100%;">RE-ENGAGE</button>
        </div>
    </div>

<script>
/** * 基础变量与初始化 */
const bgCanvas = document.getElementById('bg-canvas');
const bgCtx = bgCanvas.getContext('2d');
const canvas = document.getElementById('cvs');
const ctx = canvas.getContext('2d');
let stars = [], levels = [], queue = [], TILE = 70;
let curIdx = 0, isSwitching = false;
let state = { p:{x:0, y:0, rx:0, ry:0}, b:[], walls:[], targets:[], resets:0, totalSteps:0, sumMinSteps:0, startTime:0, finished:false };

function initStars() {
    bgCanvas.width = window.innerWidth; bgCanvas.height = window.innerHeight;
    stars = [];
    for(let i=0; i<400; i++) stars.push({ x: Math.random()*bgCanvas.width-bgCanvas.width/2, y: Math.random()*bgCanvas.height-bgCanvas.height/2, z: Math.random()*bgCanvas.width });
}
function drawStars() {
    bgCtx.fillStyle = '#050505'; bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
    bgCtx.save(); bgCtx.translate(bgCanvas.width/2, bgCanvas.height/2);
    stars.forEach(s => {
        s.z -= (5 + curIdx); if(s.z <= 0) s.z = bgCanvas.width;
        let sx = (s.x / s.z) * bgCanvas.width, sy = (s.y / s.z) * bgCanvas.height;
        let size = (1 - s.z / bgCanvas.width) * 3;
        bgCtx.fillStyle = `rgba(0, 210, 255, ${1 - s.z/bgCanvas.width})`;
        bgCtx.beginPath(); bgCtx.arc(sx, sy, size, 0, Math.PI*2); bgCtx.fill();
    });
    bgCtx.restore(); requestAnimationFrame(drawStars);
}

/** * 核心控制逻辑 */
async function startGame() {
    try {
        const r = await fetch('levels.json?v=' + Date.now());
        if (!r.ok) throw new Error("File not found");
        levels = await r.json();
        queue = levels.sort(() => .5 - Math.random()).slice(0, 12);
        state.startTime = Date.now();
        loadLevel(0);
        requestAnimationFrame(gameLoop);
    } catch (e) {
        console.error(e);
        alert("关卡加载失败！");
    }
}

function loadLevel(idx) {
    const d = queue[idx];
    state.walls = d.walls; state.targets = d.targets;
    state.initP = d.player; state.initB = d.boxes;
    state.sumMinSteps += d.min;
    const maxRows = d.walls.length, maxCols = d.walls[0].length;
    const screenFit = Math.min((window.innerWidth*0.8)/maxCols, (window.innerHeight*0.5)/maxRows);
    TILE = Math.min(screenFit, 70); 
    state.p.x = d.player[0]; state.p.y = d.player[1];
    state.p.rx = d.player[0] * TILE; state.p.ry = d.player[1] * TILE;
    state.b = d.boxes.map(b => ({ x: b[0], y: b[1], rx: b[0]*TILE, ry: b[1]*TILE }));
    isSwitching = false;
}

function performReset() {
    if(state.finished || isSwitching) return;
    if(confirm("ABORT MISSION? -500 PTS")) {
        state.p.x = state.initP[0]; state.p.y = state.initP[1];
        state.b = state.initB.map(b => ({x:b[0], y:b[1], rx:b[0]*TILE, ry:b[1]*TILE}));
        state.resets++;
    }
    canvas.focus();
}

function move(dx, dy) {
    if(state.finished || isSwitching) return;
    let nx = state.p.x + dx, ny = state.p.y + dy;
    if(state.walls[ny][nx] === 1) return;
    let bi = state.b.findIndex(b => b.x === nx && b.y === ny);
    if(bi !== -1) {
        let bx = nx + dx, by = ny + dy;
        if(state.walls[by][bx] === 1 || state.b.some(b => b.x===bx && b.y===by)) return;
        state.b[bi].x = bx; state.b[bi].y = by;
    }
    state.p.x = nx; state.p.y = ny;
    state.totalSteps++;
    const t = document.getElementById('st');
    t.classList.remove('pulse'); void t.offsetWidth; t.classList.add('pulse');
}

/** * 统一输入监听 (解决移动两格和手机锁死) */
// 1. 键盘监听 (唯一)
window.addEventListener('keydown', e => {
    if (state.finished || isSwitching) return;
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();
    const k = e.key.toLowerCase();
    if(k==="arrowup"||k==="w") move(0,-1); 
    else if(k==="arrowdown"||k==="s") move(0,1);
    else if(k==="arrowleft"||k==="a") move(-1,0); 
    else if(k==="arrowright"||k==="d") move(1,0);
    else if(k==="r") performReset();
});

// 2. 滑动手势监听 (重新激活手机端)
let touchStart = null;
document.addEventListener('touchstart', e => { 
    touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY }; 
}, { passive: false });

document.addEventListener('touchend', e => {
    if (!touchStart || isSwitching || state.finished) return;
    const dx = e.changedTouches[0].clientX - touchStart.x;
    const dy = e.changedTouches[0].clientY - touchStart.y;
    if (Math.max(Math.abs(dx), Math.abs(dy)) > 30) {
        if (Math.abs(dx) > Math.abs(dy)) move(dx > 0 ? 1 : -1, 0);
        else move(0, dy > 0 ? 1 : -1);
    }
    touchStart = null;
}, { passive: false });

// 3. 重置按钮
document.getElementById('reset-btn').addEventListener('pointerdown', (e) => {
    e.preventDefault();
    performReset();
});

/** * 渲染与循环 */
function gameLoop() {
    if(!state.finished) {
        state.p.rx += (state.p.x * TILE - state.p.rx) * 0.3;
        state.p.ry += (state.p.y * TILE - state.p.ry) * 0.3;
        state.b.forEach(b => { b.rx += (b.x * TILE - b.rx) * 0.3; b.ry += (b.y * TILE - b.ry) * 0.3; });
        drawGame();
        updateUI();
        if(!isSwitching && state.b.every(b => state.targets.some(t => t[0]===b.x && t[1]===b.y))) {
            isSwitching = true;
            document.getElementById('msg').style.opacity = 1;
            setTimeout(() => {
                document.getElementById('msg').style.opacity = 0;
                if (curIdx < 11) { curIdx++; loadLevel(curIdx); }
                else { state.finished = true; showFinalResult(); }
            }, 500);
        }
        requestAnimationFrame(gameLoop);
    }
}

function drawGame() {
    const d = state.walls;
    canvas.width = d[0].length * TILE; canvas.height = d.length * TILE;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    d.forEach((r,y) => r.forEach((v,x) => {
        if(v===1) { 
            ctx.fillStyle="#1a1a1a"; ctx.beginPath(); ctx.roundRect(x*TILE+2, y*TILE+2, TILE-4, TILE-4, 4); ctx.fill(); 
            ctx.strokeStyle="rgba(0, 210, 255, 0.3)"; ctx.stroke();
        } else { ctx.fillStyle="rgba(20,20,20,0.6)"; ctx.fillRect(x*TILE, y*TILE, TILE, TILE); }
    }));
    state.targets.forEach(t => {
        ctx.strokeStyle="#00ff88"; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(t[0]*TILE+TILE/2, t[1]*TILE+TILE/2, TILE/4, 0, 7); ctx.stroke();
    });
    state.b.forEach(b => {
        const ok = state.targets.some(t => t[0]===b.x && t[1]===b.y);
        ctx.fillStyle = ok ? "#00ff88" : "#ff8800";
        ctx.beginPath(); ctx.roundRect(b.rx+6, b.ry+6, TILE-12, TILE-12, 2); ctx.fill();
        if(ok) { ctx.shadowBlur = 15; ctx.shadowColor = "#00ff88"; }
    });
    ctx.shadowBlur = 15; ctx.shadowColor = "#00d2ff";
    ctx.fillStyle="#00d2ff"; ctx.beginPath(); ctx.arc(state.p.rx+TILE/2, state.p.ry+TILE/2, TILE/3, 0, 7); ctx.fill();
    ctx.shadowBlur = 0;
}

function updateUI() {
    const elapsed = Date.now() - state.startTime + (state.resets * 10000);
    const s = Math.floor(elapsed/1000), ms = Math.floor(elapsed%1000);
    document.getElementById('st').innerHTML = `${s.toString().padStart(2,'0')}<span class="ms">.${ms.toString().padStart(3,'0')}</span>`;
    document.getElementById('lv').innerText = curIdx + 1;
    document.getElementById('steps').innerText = state.totalSteps;
}

function showFinalResult() {
    const pure = Math.floor((Date.now()-state.startTime)/1000), penalty = state.resets*10, total = pure+penalty;
    const score = Math.max(0, Math.round(5000*Math.pow(state.sumMinSteps/state.totalSteps, 1.8)) + Math.max(0, 5000-(total-150)*80) - (state.resets*500));
    const rank = score >= 9500 ? "S" : score >= 8500 ? "A" : score >= 7000 ? "B" : "C";
    document.getElementById('f-score').innerText = score.toLocaleString();
    document.getElementById('f-rank').innerText = "RANK: " + rank;
    document.getElementById('f-rank').style.color = (rank==="S"?"#00ff88":"#00d2ff");
    document.getElementById('f-steps').innerText = state.totalSteps;
    document.getElementById('f-min').innerText = state.sumMinSteps;
    document.getElementById('f-pure').innerText = pure+"s";
    document.getElementById('f-penalty').innerText = "+"+penalty+"s";
    document.getElementById('res').style.display = 'flex';
}

initStars(); 
drawStars();
    // 彻底禁止长按弹出菜单和选择
window.oncontextmenu = function(e) { e.preventDefault(); e.stopPropagation(); return false; };

// 修正滑动手势，添加 preventDefault 防止某些浏览器尝试滚动
document.addEventListener('touchstart', e => { 
    // 防止多指缩放触发的选择
    if (e.touches.length > 1) e.preventDefault();
    touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY }; 
}, { passive: false });

document.addEventListener('touchmove', e => {
    // 强制禁止任何滑动产生的页面偏移
    e.preventDefault();
}, { passive: false });
startGame();
</script>
</body>
</html>


