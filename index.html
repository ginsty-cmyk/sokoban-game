<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sokoban Speedrun Hardcore</title>
    <style>
        :root { 
            --bg: #1a1a1a; --panel: #2d2d2d; --accent: #00a8ff; 
            --danger: #ff4757; --success: #2ed573; --text: #f1f2f6; 
        }
        /* 基础样式与防晃动配置 */
        * { user-select: none; -webkit-tap-highlight-color: transparent; }
        body { 
            background: var(--bg); display: flex; flex-direction: column; align-items: center; 
            font-family: 'Segoe UI', system-ui, sans-serif; color: var(--text); 
            margin: 0; overflow: hidden; height: 100vh; 
        }
        
        /* 计时器美术强化 */
        #timer-box {
            margin-top: 20px; text-align: center; background: rgba(0,0,0,0.3);
            padding: 10px 40px; border-radius: 15px; border-left: 5px solid var(--danger);
        }
        #st { 
            font-family: 'Courier New', monospace; font-size: 4rem; 
            font-weight: 900; color: var(--danger); text-shadow: 0 0 15px rgba(255, 71, 87, 0.5);
            line-height: 1;
        }
        .timer-label { font-size: 0.8rem; text-transform: uppercase; color: #888; letter-spacing: 2px; }

        #ui-stats { 
            margin: 15px 0; display: flex; gap: 25px; font-size: 1.1rem; font-weight: bold; align-items: center;
        }
        .stat-item span { color: var(--accent); }

        /* 重置按钮 */
        #reset-btn {
            background: var(--danger); color: white; border: none; padding: 10px 25px;
            border-radius: 10px; font-weight: bold; font-size: 1rem; cursor: pointer;
            box-shadow: 0 4px 0 #b33939; transition: 0.1s; outline: none;
        }
        #reset-btn:active { transform: translateY(3px); box-shadow: 0 1px 0 #b33939; }

        #game-container { 
            position: relative; flex-grow: 1; display: flex; 
            flex-direction: column; align-items: center; justify-content: center; 
            width: 100%; touch-action: none; /* 关键：仅在此区域禁用默认触摸 */
        }
        canvas { 
            background: #333; border-radius: 8px; 
            box-shadow: 0 0 40px rgba(0,0,0,0.5); border: 2px solid #444;
            outline: none; /* 移除焦点边框 */
        }

        /* 结算弹窗 */
        .modal { 
            display: none; position: fixed; inset: 0; 
            background: rgba(0,0,0,0.95); backdrop-filter: blur(10px);
            color: white; flex-direction: column; justify-content: center; align-items: center; z-index: 100; 
        }
        .modal-content { background: #fff; color: #333; padding: 30px; border-radius: 24px; width: 80%; max-width: 400px; text-align: center; }
        .score-val { font-size: 50px; font-weight: 900; color: var(--danger); }
        
        #msg { position: fixed; top: 15%; font-size: 32px; color: var(--success); font-weight: 900; opacity: 0; transition: 0.3s; pointer-events: none; }
    </style>
</head>
<body>
    <div id="msg">LEVEL CLEAR</div>
    
    <div id="timer-box">
        <div class="timer-label">Time Pressure</div>
        <div id="st">000</div>
    </div>

    <div id="ui-stats">
        <div class="stat-item">LV: <span id="lv">1</span>/12</div>
        <div class="stat-item">STEPS: <span id="steps">0</span></div>
        <button id="reset-btn">RESET (R)</button>
    </div>
    
    <div id="game-container">
        <canvas id="cvs"></canvas>
    </div>

    <div id="res" class="modal">
        <div class="modal-content">
            <h2 style="margin:0">CHALLENGE COMPLETE</h2>
            <div id="f-score" class="score-val">0</div>
            <p id="f-rank" style="font-weight:bold; font-size:1.5rem; color:var(--accent)">RANK: C</p>
            <div style="text-align:left; margin: 15px 0; border-top: 1px solid #eee; padding-top: 10px; font-size: 0.9rem;">
                <div>总步数: <span id="f-steps">0</span></div>
                <div>纯耗时: <span id="f-pure">0</span>s</div>
                <div>重置罚时: <span id="f-penalty">0</span>s</div>
            </div>
            <button onclick="location.reload()" style="background:var(--accent); color:white; border:none; padding:12px 30px; border-radius:8px; font-weight:bold; cursor:pointer;">TRY AGAIN</button>
        </div>
    </div>

<script>
const TILE = 75;
const canvas = document.getElementById('cvs');
const ctx = canvas.getContext('2d');
let levels = [], queue = [], curIdx = 0, isSwitching = false;
let state = { p:{x:0, y:0, rx:0, ry:0}, b:[], walls:[], targets:[], resets:0, totalSteps:0, sumMinSteps:0, startTime:0, finished:false };

// 1. 移动端滑动逻辑
let touchStart = null;
document.addEventListener('touchstart', e => { 
    touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY }; 
}, { passive: true });

document.addEventListener('touchend', e => {
    if (!touchStart || isSwitching || state.finished) return;
    const dx = e.changedTouches[0].clientX - touchStart.x;
    const dy = e.changedTouches[0].clientY - touchStart.y;
    if (Math.max(Math.abs(dx), Math.abs(dy)) > 30) {
        if (Math.abs(dx) > Math.abs(dy)) move(dx > 0 ? 1 : -1, 0);
        else move(0, dy > 0 ? 1 : -1);
    }
    touchStart = null;
}, { passive: true });

// 2. 键盘监听增强 (解决部署后失效问题)
window.addEventListener('keydown', function(e) {
    if (state.finished || isSwitching) return;
    
    // 阻止方向键滚动页面
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) {
        e.preventDefault();
    }

    const key = e.key.toLowerCase();
    switch(key) {
        case "arrowup": case "w": move(0, -1); break;
        case "arrowdown": case "s": move(0, 1); break;
        case "arrowleft": case "a": move(-1, 0); break;
        case "arrowright": case "d": move(1, 0); break;
        case "r": resetLevel(true); break;
    }
}, false);

// 3. UI 按钮逻辑
document.getElementById('reset-btn').onclick = () => { 
    canvas.focus(); // 确保点击后焦点回到游戏
    if(confirm("确定重置本关？(罚时10秒+分值重扣)")) resetLevel(true); 
};

async function init() {
    // 核心：让 Canvas 可接受焦点
    canvas.tabIndex = 1;
    canvas.focus();

    try {
        const r = await fetch('levels.json');
        levels = await r.json();
        queue = levels.sort(() => .5 - Math.random()).slice(0, 12);
        state.startTime = Date.now();
        loadLevel(0);
        requestAnimationFrame(loop);
    } catch (e) { 
        alert("无法加载 levels.json，请检查文件路径。"); 
    }
}

function loadLevel(idx) {
    const d = queue[idx];
    state.walls = d.walls; state.targets = d.targets;
    state.initP = d.player; state.initB = d.boxes;
    state.sumMinSteps += d.min;
    state.p.x = d.player[0]; state.p.y = d.player[1];
    state.p.rx = d.player[0] * TILE; state.p.ry = d.player[1] * TILE;
    state.b = d.boxes.map(b => ({ x: b[0], y: b[1], rx: b[0]*TILE, ry: b[1]*TILE }));
    isSwitching = false;
}

function resetLevel(manual) {
    if(isSwitching || state.finished) return;
    state.p.x = state.initP[0]; state.p.y = state.initP[1];
    state.b = state.initB.map(b => ({ x: b[0], y: b[1], rx: b[0]*TILE, ry: b[1]*TILE }));
    if(manual) state.resets++;
}

function move(dx, dy) {
    if(state.finished || isSwitching) return;
    let nx = state.p.x + dx, ny = state.p.y + dy;
    if(state.walls[ny][nx] === 1) return;
    let bi = state.b.findIndex(b => b.x === nx && b.y === ny);
    if(bi !== -1) {
        let bx = nx + dx, by = ny + dy;
        if(state.walls[by][bx] === 1 || state.b.some(b => b.x===bx && b.y===by)) return;
        state.b[bi].x = bx; state.b[bi].y = by;
    }
    state.p.x = nx; state.p.y = ny;
    state.totalSteps++;
}

function loop() {
    if(state.finished) return;
    state.p.rx += (state.p.x * TILE - state.p.rx) * 0.28;
    state.p.ry += (state.p.y * TILE - state.p.ry) * 0.28;
    state.b.forEach(b => { b.rx += (b.x * TILE - b.rx) * 0.28; b.ry += (b.y * TILE - b.ry) * 0.28; });
    
    draw();
    updateUI();
    if(!isSwitching && state.b.every(b => state.targets.some(t => t[0]===b.x && t[1]===b.y))) triggerWin();
    requestAnimationFrame(loop);
}

function triggerWin() {
    isSwitching = true;
    document.getElementById('msg').style.opacity = 1;
    setTimeout(() => {
        document.getElementById('msg').style.opacity = 0;
        if (curIdx < 11) { curIdx++; loadLevel(curIdx); }
        else { state.finished = true; showFinalResult(); }
    }, 600);
}

function draw() {
    const d = state.walls;
    canvas.width = d[0].length * TILE; canvas.height = d.length * TILE;
    d.forEach((r,y) => r.forEach((v,x) => {
        if(v===1) { ctx.fillStyle="#444"; ctx.beginPath(); ctx.roundRect(x*TILE+2, y*TILE+2, TILE-4, TILE-4, 8); ctx.fill(); }
        else { ctx.fillStyle="#2a2a2a"; ctx.fillRect(x*TILE, y*TILE, TILE, TILE); }
    }));
    state.targets.forEach(t => {
        ctx.strokeStyle="#2ed573"; ctx.setLineDash([4, 4]); ctx.lineWidth=2;
        ctx.beginPath(); ctx.arc(t[0]*TILE+TILE/2, t[1]*TILE+TILE/2, 12, 0, 7); ctx.stroke(); ctx.setLineDash([]);
    });
    // 箱子扩大尺寸 (TILE-14)
    state.b.forEach(b => {
        const ok = state.targets.some(t => t[0]===b.x && t[1]===b.y);
        ctx.fillStyle = ok ? "#2ed573" : "#e67e22";
        ctx.beginPath(); ctx.roundRect(b.rx+7, b.ry+7, TILE-14, TILE-14, 10); ctx.fill();
        if(ok) { ctx.strokeStyle="white"; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(b.rx+TILE/2, b.ry+TILE/2, 6, 0, 7); ctx.stroke(); }
    });
    ctx.fillStyle="#00a8ff"; ctx.beginPath(); ctx.arc(state.p.rx+TILE/2, state.p.ry+TILE/2, 25, 0, 7); ctx.fill();
}

function updateUI() {
    const elapsed = (Date.now() - state.startTime)/1000;
    const displayTime = Math.floor(elapsed + (state.resets * 10));
    document.getElementById('st').innerText = displayTime.toString().padStart(3, '0');
    document.getElementById('lv').innerText = curIdx + 1;
    document.getElementById('steps').innerText = state.totalSteps;
}

function showFinalResult() {
    const pureTime = Math.floor((Date.now() - state.startTime)/1000);
    const totalTime = pureTime + (state.resets * 10);
    let stepRatio = state.sumMinSteps / state.totalSteps;
    let stepScore = Math.round(5000 * Math.pow(stepRatio, 1.5)); 
    let timeScore = Math.max(0, 5000 - (totalTime - 150) * 50);
    let finalScore = Math.max(0, stepScore + timeScore - (state.resets * 500));
    let rank = finalScore >= 9200 ? "S" : finalScore >= 8000 ? "A" : finalScore >= 6500 ? "B" : "C";

    document.getElementById('f-steps').innerText = state.totalSteps;
    document.getElementById('f-pure').innerText = pureTime;
    document.getElementById('f-penalty').innerText = state.resets * 10;
    document.getElementById('f-score').innerText = finalScore.toLocaleString();
    document.getElementById('f-rank').innerText = "RANK: " + rank;
    document.getElementById('res').style.display = 'flex';
}

// 自动初始化
init();
</script>
</body>
</html>
